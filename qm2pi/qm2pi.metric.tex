\section{Space from behavior}

We now give the main theorem of the paper.

\begin{theorem}[main]
  The metric induced by the inner product coincides with the metric
  induced by bisimulation.
\end{theorem}

\paragraph{Proof sketch} The metric induced by bisimulation (when we
put in the definition) will be the quote of the smallest witness of
the smallest distinguishing formulae. The inner product quotes the
effect of calculating the difference (what's left after you whack $P$
against $Q$ and let them run). These two notions coincide.

To make this statement precise enough to prove, we have a number of
obligations to discharge. First of all, we have to give the metric
induced by bisimulation. To do this, we need to give the
Hennessy-Milner construction for the process calculus defined
above. This logic enjoys the usual property that processes are
bisimilar if and only if there is no distinguishing formula. We will
take the distance between processes to be the smallest distinguishing
formula. Thus, we have to give a measure of the size of the formula of
this logic, which we write $\#(\phi)$.

With these definitions in hand we show that the quotation of the
smallest witness of the smallest formulae is ``bisimilar'' to the name
computed by the inner product. Notice that up this point, the
calculation we are calling inner product has yet to be proved to
provide a metric. Establishing the correspondence to the HML-induced
metric is actually what gives us the right to think of the inner
product calculation as a metric.

Note that it is possible to give an alternative definition following
Caires' notion of a characteristic formula. If $\meaningof{\phi}$
denotes the set of processes satisfying $\phi$ and
$\meaningof{P}_{\phi}$ denotes the characteristic formula of a
process, then we can show that
$\meaningof{\meaningof{\innerprod{P}{Q}}_{\phi}} =
\meaningof{\quotep{D}_{\phi}(P,Q)}$ where

\begin{definition}[metric]  
  \begin{mathpar}
    \Delta(P,Q) := \{ \phi \; : \; (P \models \phi \; \& \; Q \not\models \phi) \vee (P \not\models \phi \; \& \; Q \models \phi) \}
    \and
    D_{\phi}(P,Q) := \bigvee_{\phi \in \Delta(P,Q)} \phi
    \and
    \quotep{D}_{\phi}(P,Q) := \quotep{\bigvee_{\phi \in \Delta(P,Q)} \phi}
    \and
    D(P,Q) := min \{ \#(\phi) \; : \; \phi \in \Delta(P,Q) \}
  \end{mathpar}
\end{definition}

So, without further ado, we give you the HML construction for a
reflective calculus.

\subsection{Namespace logic: a Hennessy-Milner logic of reflection}
Namespace logic resides in the subfamily of Hennessy-Milner logics
discovered by Caires and Cardelli and known as spatial logics
\cite{DBLP:journals/tcs/CairesC04}. Thus, as is seen below, in
addition to the action modalities, we also find formulae for
\emph{separation}, corresponding, at the logical level, to the
structural content of the parallel operator at the level of the
calculus. Likewise, we have quantification over names. 

In this connection, however, we find an interesting difference between
spatial logics investigated heretofore and this one. As in the
calculus, we find no need for an operator corresponding to the $\nu$
construction. However, revelation in spatial logic, is a structural
notion \cite{DBLP:journals/tcs/CairesC04}. It detects the
\emph{declaration} of a new name. No such information is available in
the reflective calculus or in namespace logic. The calculus and the
logic can arrange that names are used in a manner consistent with
their being declared as new in the {\pic}, but it cannot detect the
declaration itself. Seen from this perspective, revelation is a
somewhat remarkable observation, as it seems to be about detecting the
programmer's intent.

\begin{mathpar}
  \inferrule* [lab=boolean connectives] {} {{\phi,\psi} \bc \ptrue \; | \; \neg \phi \; |\; \phi \& \psi}
  \and
  \inferrule* [lab=spatial connectives] {} {| \; \pzero \; | \; \phi | \psi}
  \and
  \inferrule* [lab=nominal connectives] {} {| \; \pdropf{b} \; | \; \pquant{n}{\psi}{\phi}}  
  \and
  \inferrule* [lab=behavioral connectives] {} {| \; \pprefix{a}{\vec{b}}{\phi} \; | \; \plift{a}{\vec{\phi}}}
  \and
  \inferrule* [lab=fixpt connectives] {} {| \; \pgfp{X}{\phi} \; | \; X}
  \and
  \inferrule* [lab=patterns] {} {{a} \bc \quotep{\phi} \; | \; b}
  \and
  \inferrule* [lab=literals] {} {{b} \bc \quotep{P} \; | \; n}
\end{mathpar}

We let $\PFormula$ denote the set of formulae generated by the
$\phi$-production, $\QFormula$ denote the set of formulae generated by
the $a$-production and $\PropVar$ denote the set of propositional
variables used in the $\textsf{rec}$ production.

Inspired by Caires' presentation of spatial logic
\cite{DBLP:conf/fossacs/Caires04}, we give the semantics in terms of
sets of processes (and names). We need the notion of a valuation $v :
\PropVar \to \wp(\Proc)$, and use the notation $v\substn{\mathcal{S}}{X}$ to mean 

\begin{eqnarray}
  v\substn{\mathcal{S}}{X}(Y) & = &
  \left\{ \begin{array}{ccc}
      S & & Y = X \\
      v(Y) & & otherwise \\
    \end{array}
  \right.\nonumber
\end{eqnarray}

The meaning of formulae is given in terms of two mutually recursive functions,

\begin{eqnarray}
\pmeaningof{ - }( - ) : \PFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\Proc) \nonumber\\
\nmeaningof{ - }( - ) : \QFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\QProc) \nonumber
\end{eqnarray}

taking a formula of the appropriate type and a valuation, and
returning a set of processes or a set of names, respectively.

\begin{eqnarray}
  \pmeaningof{\ptrue}(v) & = & \Proc \nonumber \\ 
  \pmeaningof{\pzero}(v) & = & \{ P : P \scong \pzero \} \nonumber \\ 
  \pmeaningof{\neg \phi}(v) & = & \Proc / \pmeaningof{\phi}(v) \nonumber\\
  \pmeaningof{\phi \& \psi}(v) & = & \pmeaningof{\phi}(v) \cap \pmeaningof{\psi}(v) \nonumber\\
  \pmeaningof{\binpar{\phi}{\psi}}(v) & = &
  \{ P : \exists P_0, P_1.P \scong \binpar{P_0}{P_1}, \; P_0 \in \pmeaningof{\phi}(v), \;  P_1 \in \pmeaningof{\psi}(v) \} \nonumber\\
  \pmeaningof{\pdropf{b}}(v) & = & \{ P : \exists Q, P'.P \scong \binpar{Q}{\dropn{x}}, \; x \in \nmeaningof{b}(v) \} \nonumber\\	
  \pmeaningof{\plift{a}{\phi}}(v) & = & \{ P : \exists x, P'.P \scong \lift{x}{P'},
                                           \; x \in \nmeaningof{a}(v), 
                                           \; P' \in \pmeaningof{\phi}(v) \} \nonumber\\
  \pmeaningof{\pprefix{a}{b}{\phi}}(v) & = & \{ P : \exists x, P'.P \scong \prefix{x}{y}{P'}, x \in \nmeaningof{a}(v), \nonumber\\
                                   &   &            \; \; \; \forall c . \exists z . {P'}\substn{z}{y} \in \pmeaningof{{\phi}\substn{c}{b}}(v) \} \nonumber\\
  \pmeaningof{\pgfp{X}{\phi}}(v) & = & \cup \{ \mathcal{S} \subseteq \Proc : \mathcal{S} \subseteq \pmeaningof{\phi}(v\substn{\mathcal{S}}{X})\} \nonumber\\
  \pmeaningof{\pquant{n}{\psi}{\phi}}(v) & = & \cap_{x \in \nmeaningof{\quotep{\psi}}(v)} \pmeaningof{{\phi}\substn{x}{n}}(v) \nonumber\\
  \nmeaningof{\quotep{\phi}}(v) & = & \{ x : x \nameeq \quotep{P}, P \in \pmeaningof{\phi}(v) \} \nonumber\\
  \nmeaningof{\quotep{P}}(v) & = & \{ x : x \nameeq  \quotep{P} \} \nonumber
\end{eqnarray}

We say $P$ witnesses $\phi$ (resp., $x$ witnesses $\quotep{\phi}$),
written $P \models \phi$ (resp., $x \models \quotep{\phi}$) just when
$\forall v . P \in \meaningof{\phi}(v)$ (resp., $\forall v . x \in \meaningof{\quotep{\phi}}(v)$).

\begin{theorem}[Equivalence]
	$P \wbbisim Q \riff \forall \phi . P \models \phi \riff Q \models \phi .$
\end{theorem}

The proof employs an adaptation of the standard strategy. As noted in
the introduction, this theorem means that there is no algorithm
guaranteeing that a check for the witness relation will terminate.

\subsubsection{Syntactic sugar }

In the examples below, we freely employ the usual DeMorgan-based
syntactic sugar. For example,

\begin{eqnarray}
	\phi \Rightarrow \psi & \triangleq & \neg ( \phi \& \neg \psi ) \nonumber\\
	\phi \vee \psi & \triangleq & \neg ( \neg \phi \& \neg \psi ) \nonumber
\end{eqnarray}

Also, when quantification ranges over all of $\Proc$, as in
$\pquant{n}{\quotep{\ptrue}}{\phi}$, we omit the typing for the
quantification variable, writing $\pquantuntyped{n}{\phi}$.

\subsubsection{An example}

\paragraph{Controlling access to namespaces}

Suppose that $\quotep{\phi}$ describes some namespace, i.e. some
collection of names. We can insist that a process restrict its next
input to names in that namespace by insisting that it witness the formula

\begin{eqnarray}
  \pprefix{\quotep{\phi}}{b}{\ptrue} \& \neg \pprefix{\quotep{\neg \phi}}{b}{\ptrue} \nonumber
\end{eqnarray}

which simply says the the process is currently able to take input from
a name in the namespace $\quotep{\phi}$ and is not capable of input on
any name not in that namespace. In a similar manner, we can limit a
server to serving only inputs in $\quotep{\phi}$ throughout the
lifetime of its behavior \footnote{Of course, this formula also says
  the server never goes down, either -- or at least is always willing
  to take such input...;-)}

\begin{eqnarray}
  \pgfp{X}{\pprefix{\quotep{\phi}}{b}{X} \& \neg \pprefix{\quotep{\neg \phi}}{b}{\ptrue}} \nonumber
\end{eqnarray} 

This formula is reminiscent of the functionality of a firewall, except
that it is a \emph{static} check. A process witnessing this formula
will behave as though it were behind a firewall admitting only access
to the ports in $\quotep{\phi}$ without the need for the additional
overhead of the watchdog machinery.

\subsection{The size of a formula}

We give a recursive definition of the size of a formula, written
$\#(\phi)$, in terms of a measure of the set of processes it
denotes. 

% To find this formula we note that we have two mutually
% recursive equations to solve. If we parameterize the size in a
% measure, $\mu$, on the set of processes, then we have

% \begin{mathpar}
%   \#(\phi)(\mu) := \mu(\meaningof{\phi})
% \end{mathpar}

% while if we parameterize a measure on a notion of formula size,
% $\sigma$, we have

% \begin{mathpar}
%   \mu(S)(\sigma) := \Sigma_{P \in S} \sigma(\meaningof{P}_{\phi})
% \end{mathpar}

\begin{definition}[measure]
  For the time being we simply demand a Lebesgue measure, written
  $\mu_{\Proc}$ on the set $\Proc$, and define
  \begin{mathpar}
    \#(\phi) := \mu_{\Proc}(\meaningof{\phi})
  \end{mathpar}
\end{definition}

\begin{definition}[witness]
  TBD
\end{definition}


