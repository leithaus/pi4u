% ------------------------------------------------------------------------
% AMS-LaTeX Paper ********************************************************
% ------------------------------------------------------------------------
% Submitted:      Dec 15 2003
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO(mike): locating a closure at a name: how to translate a closure into a process that gets stuck into the cell



%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
%\documentclass[]{amsart}
%\documentclass[]{sig-alternate}
%\documentclass[]{acm_proc_article-sp}
%\documentclass[]{llncs}
\documentclass[submission,copyright,creativecommons]{eptcs}

%\documentclass[]{prentcsmacro}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}

% From Allen's stable.
\usepackage{bigpage}
\usepackage{bcprules}
%\usepackage{code}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{mathtools}
%\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{caption}
%\usepackage{multicol}

% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\ldrb}{(\!(}
\newcommand{\rdrb}{)\!)}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
%\newcommand{\concat}{\mathbin{.}}
\newcommand{\concat}{\Rightarrow}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
%\newcommand{\names}[1]{\mathbin{\mathcal{N}(#1)}}
\newcommand{\names}[1]{\mathbin{\bold{N}(#1)}}
%\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\freenames}[1]{\mathbin{\bold{FN}(#1)}}
%\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\bold{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\binselect}[2]{#1 \altern #2}
\newcommand{\outputp}[2]{#1 ! ( * #2 )}
\newcommand{\prefix}[3]{#1 ? ( #2 ) \concat #3}
\newcommand{\lift}[2]{#1 ! ( #2 )}
%\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\quotep}[1]{@#1}
\newcommand{\dropn}[1]{*#1}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\int #1}
\newcommand{\xbangp}[2]{\int_{#2} #1}
\newcommand{\bangxp}[2]{\int^{#2} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\widehat{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\widehat{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}
\newcommand{\pmeaningof}[1]{\ldb #1 \rdb}
\newcommand{\nmeaningof}[1]{\ldrb #1 \rdrb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\defneqls}{:\!=}
\newcommand{\defneqls}{\coloneqq}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}		% parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}		% Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}		
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}	%expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}	%expansion greater (amssymb required)
\newcommand{\beq}{\sim}		%barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}	%weak barbed congruent
\newcommand{\wbeq}{\approx}	%weak barbed congruent
\newcommand{\sheq}{\simeq}	%symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% End piduce contribution

% rho logic

\newcommand{\ptrue}{\mathbin{true}}
\newcommand{\psatisfies}[2]{#1 \models #2}
\newcommand{\pdropf}[1]{\rpquote #1 \lpquote}
\newcommand{\pquotep}[1]{\lpquote #1 \rpquote}
\newcommand{\plift}[2]{#1 ! ( #2 )}
\newcommand{\pprefix}[3]{\langle #1 ? #2 \rangle #3}
\newcommand{\pgfp}[2]{\textsf{rec} \; #1 \mathbin{.} #2}
\newcommand{\pquant}[3]{\forall #1 \mathbin{:} #2 \mathbin{.} #3}
\newcommand{\pquantuntyped}[2]{\forall #1 \mathbin{.} #2}
\newcommand{\riff}{\Leftrightarrow}

\newcommand{\PFormula}{\mathbin{PForm}}
\newcommand{\QFormula}{\mathbin{QForm}}
\newcommand{\PropVar}{\mathbin{\mathcal{V}}}

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\ctcategory}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
 \newtheorem{thm}{Theorem}[subsection]
 \newtheorem{cor}[thm]{Corollary}
 \newtheorem{lem}[thm]{Lemma}
 \newtheorem{prop}[thm]{Proposition}
% \theoremstyle{definition}
 \newtheorem{defn}[thm]{Definition}
% \theoremstyle{remark}
 \newtheorem{rem}[thm]{Remark}
 \newtheorem{example}[thm]{Example}
 \numberwithin{equation}{subsection}
% MATH -------------------------------------------------------------------
 \DeclareMathOperator{\RE}{Re}
 \DeclareMathOperator{\IM}{Im}
 \DeclareMathOperator{\ess}{ess}
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \newcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\rhoc}{${\textsc{rho}}$-calculus}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{Policy as Types}
% use static date to preserve date of actual publication
\newcommand{\paperversion}{Draft Version 0.1 - July 19, 2013}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

\providecommand{\event}{BEAT 2014}

\title{\papertitle}

\author{
L.G. Meredith
\institute{Biosimilarity, LLC}
\email{lgreg.meredith@biosimilarity.com}
\and
Mike Stay
\institute{Google}
\email{stay@google.com}
\and
Sophia Drossopoulou
\institute{Imperial College, London}
\email{s.drossopoulou@imperial.ac.uk}
}
\def\titlerunning{\papertitle}
\def\authorrunning{L.G. Meredith, M. Stay \& S. Drossopoulou}
%%% ----------------------------------------------------------------------
\begin{document}
%\lstset{language=erlang}
\lstset{language=}

%These margin values appear to be relative to the bigpage package settings. --cb
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{6pt}

%\title{\huge{\papertitle}}

%\address{Systems Biology, Harvard Medical School, Boston, Massachussetts, USA}

%\email{lg_meredith@hms.harvard.edu}

%\thanks{This work was completed during a visiting appointment at the Department of Systems Biology, Harvard Medical School.}

%\subjclass{Primary 47A15; Secondary 46A32, 47D20}

%\keywords{ object-capability, concurrency, message-passing, policy, types, Curry-Howard }

%\date{April 6, 2002.}

%\dedicatory{}

%\commby{Daniel J. Rudolph}

%%% ----------------------------------------------------------------------

\begin{abstract}
%\normalsize{ 
  Drossopoulou and Noble \cite{Drossopoulou:2013:NCP:2489804.2489811}
  argue persuasively for the need for a means to express policy in
  object-capability-based systems. We investigate a practical means to
  realize their aim via the Curry-Howard isomorphism
  \cite{Abramsky:1992:PP:194588.194591}. Specifically, we investigate
  representing policy as types in a behavioral type system for the
  \rhoc\; \cite{DBLP:conf/tgc/MeredithR05}, a reflective higher-order
  variant of the \pic\; \cite{milner91polyadicpi}.
%}
\end{abstract}

% \noindent
% {\large \textbf{Submission to WPES}}\\
% \rule{6.25in}{0.75pt}\\\\\\

%%% ----------------------------------------------------------------------
\maketitle
%%% ----------------------------------------------------------------------

% \begin{center}
% \paperversion\\
% \end{center}

% \begin{toc}
% \tableofcontents
% \end{toc}

% \newpage
% ------------------------------------------------------------------------

\section{Introduction}

The object-capability (ocap) security model grew out of the realization
that good object-oriented programming practice leads to good security properties.
Separation of duties leads to separation of authority; information hiding
leads to integrity; message passing leads to authorization; 
and dependency injection to authority injection.  An
ocap-secure programming language enforces these patterns: the only way an
object can modify any state but its own is by sending messages on the object
references it possesses.  Authority can then be denied simply by not providing
the relevant object reference. Ocap languages do not provide ambient, undeniable 
authority such as the global variables in JavaScript,
static mutable fields in Java and C\#, or allowing access to arbitrary objects
through pointer arithmetic as in C and C++.

The electronic society is moving steadily towards the object
capability model.  ECMAScript 5, the standard version of JavaScript
adopted by all modern browsers, introduced a new security API that
enables the web browser to be turned into an ocap-safe platform;
Google's Caja project is an implementation \cite{Caja:2013}.  Brendan
Eich, CTO of Mozilla, wrote, ``In SpiderMonkey + Gecko in Firefox, and
probably in other browsers, we actually use OCap under the hood and
have for years. $\ldots$ Any time we deviate from OCap, we regret it for both
security bug and access-checking overhead reasons.''  \cite{Eich:2013}

We would like a way to declare the authority that an object ought to
possess and then check whether the implementation matches the intent;
that is, we would like a language for declaring security policy.
Drossopoulou and Noble \cite{Drossopoulou:2013:NCP:2489804.2489811}
convincingly argue that none of the current specification methods
adequately capture all of the capability policies required to support
ocap systems. The most intriguing aspect of the capability policies
proposed in \cite{Drossopoulou:2013:NCP:2489804.2489811} is {\em
  deniability}. Deniability differs from usual style of specifications
in the following two aspects: a) it describes policies which are {\em
  open}, i.e. apply to a module as well as all its extensions, and b)
describes {\em necessary} conditions for some effect to take
place. For example, a policy may require that in order for any piece
of code to modify the balance of a bank account, it needs to have
access to that account (access to the account is a necessary
condition), and that this property is satisfied by all extensions of
the account library (open). In contrast, classical Hoare Logic
specifications \cite{Hoare:1969:ABC:363235.363259} describe sufficient
conditions and are closed.  In this paper we concentrate on the use of
the {\rhoc} \cite{DBLP:conf/tgc/MeredithR05} for expressing
deniability. To express necessary conditions, we invert the assertion
and use bisimulation (e.g. any piece of code which does not have
access to the account will be bisimilar to code in which the balance
of the account is not modified). To express openness, we adapt the
concept of the adjoint to the separation operator, i.e. any further
code P which is attached to the current code will be bisimilar to P in
parallel with code which does not modify the balance of the account.

In short, we extend the usual interpretation of $\pi$-calculus as an
ocap language to the \rhoc\; and demonstrate that the corresponding
Hennessy-Milner logic suffices to capture the key notion of
deniability. In the larger scheme, this identifies
\cite{Drossopoulou:2013:NCP:2489804.2489811}'s notion of policy with
the proposition-as-types paradigm, also known as The Curry-Howard
isomorphism \cite{Abramsky:1992:PP:194588.194591}. The Curry-Howard
isomorphism relates formal logic to type theory; it says that
propositions are to types as proofs are to programs.  Hennessy-Milner
logic lets us treat the type of a concurrent process as an assertion
that it belongs to a set of processes, all of which satisfy some
property.  We can treat these properties as contracts governing the
behavior of the process; in other words, the language of behavioral
types suffices as a security policy language for ocaps.

%%% ----------------------------------------------------------------------

\section{Interpreting capabilities}

In \cite{DBLP:Journals/Corr/MeredithSD13} we give a compositional
interpretation of (a fragment of) Javascript sufficient to encode the
central examples of Drossopoulou and Noble's paper in the
$\rhoc$. Essentially, capabilities are interpreted as channels. In
ordinary process calculi channels have no observable internal
structure. In the calculus presented here they do, providing a means
to reason about collections of channels and hence capabilities.

\subsection{The calculus}

Before giving the formal presentation of the calculus and logic where
we interpret ocap programs and policy, respectively, we begin with a
simple example that illustrate a design pattern used over and over in
this paper. Here is a mutable single-place cell for storing and
retrieving state.

\begin{lstlisting}[mathescape]
def $Cell( slot, state ) \Rightarrow$ {
  new $( v )$ {
    $v!( state )$
    $slot ? get( ret ) \Rightarrow$ { $\binpar{v?( s ) \Rightarrow ret!( s )}{Cell( slot, s )}$ } + $slot ? set( s ) \Rightarrow$ { $Cell( slot, s )$ }
  }
}
\end{lstlisting}

We read this as saying that a $Cell$ is parametric in some (initial)
$state$ and a $slot$ for accessing and mutating the cell's state. A
$Cell$ allocates a private channel $v$ where it makes the initially
supplied $state$ available to its internal computations. If on the
channel $slot$ it receives a $get$ message containing a channel $ret$
indicating where to send the state of the cell, it accesses the
private channel $v$ and sends the value it received on to the $ret$
channel; then it resumes behaving as a $Cell$. Alternatively, if it
receives a $set$ message containing some new state $s$, it simply
continues as a $Cell$ instantiated with accessor $slot$ and state $s$.

Despite the fact that this example bears a striking resemblance to
code in any of a number of popular programming libraries, it is only a
mildly sugared form of the direct representation in our calculus; and
like modern application code, it exhibits encapsulation and separation
of implementation from API: a cell's internal access to {\tt state} is
kept in a private channel {\tt v} while external access is through
{\tt slot}. Likewise this design pattern scales through composition:
when translating ocap examples expressed in {\tt ECMAScript} to
\rhoc\; we treat the state of an object as a parallel composition of
cells comprising its state. The interested reader is invited to see
\cite{DBLP:Journals/Corr/MeredithSD13} for more examples and details
of the translation.

\subsubsection{The \rhoc}

The {\rhoc} \cite{DBLP:journals/entcs/MeredithR05}
is a variant of the asynchronous polyadic {\pic}.  When names are
polarized \cite{conf/fsttcs/Odersky95}, the {\pic} is an ocap
language.  Pierce and Turner \cite{PierceTurner:PictDesign}
defined the programming language Pict as sugar over the polarized {\pic}
together with some supporting libraries; unfortunately, the authority
provided by the libraries violated the principle of least authority.
Ko\u{s}\'{i}k refactored the libraries to create Tamed Pict, recovering
an ocap language, then used it to write a defensively consistent
operating system \cite{kosik:dep}. The {\rhoc} differs from the 
{\pic} in that names are quoted processes
rather than generated by the $\nu$ operator.  Both freshness and 
polarization are provided through the use of namespaces at the type level.

We let ${P, Q, R}$ range over processes and ${x, y, z}$ range over
names, and $\vec{x}$ for sequences of names, $|\vec{x}|$ for the
length of $\vec{x}$, and $\{ \vec{y} / \vec{x} \}$ as partial maps from
names to names that may be uniquely extended to maps from processes to
processes \cite{DBLP:journals/entcs/MeredithR05}.

\begin{mathpar}
  \inferrule* [lab=IO] {} {{M,N} \bc \pzero \;|\; x?A \;|\; x!C \;|\; M+N }
  \and
  \inferrule* [lab=Abstraction] {} {{A} \bc ({x_1}, \ldots, {x_N}) \Rightarrow P}
  \and
  \inferrule* [lab=Data] {} {{C} \bc {(}{Q_1, \ldots, Q_N}{)}}
  \and
  \inferrule* [lab=Process] {} {{P,Q} \bc M \;| \;P|Q \;|\; {*}{x}}
  \and
  \inferrule* [lab=Name] {} {{x,y} \bc {@}{P}}
\end{mathpar} 

The examples from the previous section use mild (and entirely
standard) syntactic sugar: \texttt{def} making recursive definitions a
little more convenient than their higher-order encodings, \texttt{new}
making fresh channel allocation a little more convenient and
\texttt{match} for purely input-guarded choice. The interested
reader is directed to \cite{DBLP:Journals/Corr/MeredithSD13} for more details.

The calculation of the free names of a process, $P$, denoted
$\freenames{P}$ is given recursively by

\begin{mathpar}
  \inferrule* {} {\freenames{\pzero} \defneqls \emptyset }
  \and
  \inferrule* {} {\freenames{{x}{?}{( y_1, \ldots, y_N )} \Rightarrow {P}} \defneqls \{ x \} \cup (\freenames{P} \setminus \{ y_1, \ldots y_N \})}
  \and
  \inferrule* {} {\freenames{{x}{!}{( Q_1, \ldots, Q_N )}} \defneqls \{ x \} \cup \bigcup \freenames{Q_i}}
  \and
  \inferrule* {} {\freenames{\binpar{P}{Q}} \defneqls \freenames{P} \cup \freenames{Q}}
  \and
  \inferrule* {} {\freenames{{*}{x}} \defneqls \{ x \}}
\end{mathpar} 

An occurrence of $x$ in a process $P$ is \textit{bound} if it is not
free. 

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence containing $\alpha$-equivalence, $\alphaeq$, that
satisfies the following laws:

\begin{mathpar}
  \inferrule* {} {{P} \juxtap \pzero \scong \; {P} \; \scong \pzero \juxtap {P}}
  \and
  \inferrule* {} {{P} \juxtap {Q} \scong {Q} \juxtap {P}}
  \and
  \inferrule* {} {({P} \juxtap {Q}) \juxtap {R} \scong {P} \juxtap ({Q} \juxtap {R})}
\end{mathpar} 

As discussed in \cite{DBLP:conf/tgc/MeredithR05} the calculus uses an
equality, $\nameeq$, pronounced name-equivalence, recursively related
to $\alpha$-equivalence and structural equivalence, to judge when two
names are equivalent, when deciding synchronization and substitution.

The engine of computation in this calculus is the interaction between
synchronization and a form of substitution, called semantic
substitution. Semantic substitution differs from ordinary syntactic
substitution in its application to a dropped name. For more details
see \cite{DBLP:journals/entcs/MeredithR05}

\begin{eqnarray*}
(\dropn{x})  \psubstp{Q}{P}       
		& \defneqls & 
		\left\{ 
			\begin{array}{ccc} 
				Q & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.
\end{eqnarray*}

Finally equipped with these standard features we can present the
dynamics of the calculus.

The reduction rules for {\rhoc}  are
\begin{mathpar}
  \inferrule* [lab=Comm] { {x}_{0} \nameeq {x}_{1}, |\vec{y}| = |\vec{Q}| } {{{ x_{0}{?}{(}{\vec{y}}{)} \concat {P}}\juxtap {x_{1}}{!}{(}{\vec{Q}}{)}}
\red {{P}{\{}\quotep{\vec{Q}}{/}{\vec{y}}{\}}}}
  \and
  \inferrule* [lab=Par]{{P} \red {P}'}{{{P} \juxtap {Q}} \red {{P}' \juxtap {Q}}}
  \and
  \inferrule* [lab=Equiv]{{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}
\end{mathpar} 

The context rules, $\textsc{Par}$ and $\textsc{Equiv}$, are entirely standard and we do
not say much about them here. The communication rule makes it possible
for agents to synchronize at name-equivalent guards and communicate
processes packaged as names. Here is a simple example of the use of
synchronization, reduction and quasiquote: $x{(}{z}{)} \Rightarrow
{w}{!}{(}{y}{!}{(}{*}{z}{)}{)} \juxtap x{!}{(}{P}{)} \red
{w}{!}{(}{y}{!}{(}P{)}{)}$. The input-guarded process, $x{(}{z}{)}
\Rightarrow {w}{!}{(}{y}{!}{(}{*}{z}{)}{)}$, waits to receive the code
of $P$ from the output-guarded data, $x{!}{(}{P}{)}$, and then reduces
to a new process the body of which is rewritten to include $P$,
${w}{!}{(}{y}{!}{(}P{)}{)}$.

Bisimulation, one of the central features of process calculi provides
an effective notion of substitutability together with a range of
powerful proof techniques. For this paper we focus principally on the
use of logic to interpret policy and thus need connect the ideas of
logical equivalence and bisimulation. The main theorem of the next
section relates the logic to bisimulation. Meanwhile, the experienced
reader should note that the set of names of the {\rhoc} is
\textit{global}. It is impossible, in the grammar of processes, to
guard terms from being placed into contexts that can potentially
observe communication, so we provide a place for reasoning about such
limitations on the scope of observation in the theory of bisimulation.

\begin{defn}
An \emph{observation relation}, $\downarrow_{\mathcal N}$, over a set
of names, $\mathcal N$, is the smallest relation satisfying the rules
below.

\begin{mathpar}
\inferrule* [lab=Out-barb]{y \in {\mathcal N}, \; x \nameeq y}
		  {\outputp{x}{v} \downarrow_{\mathcal N} x}
\and
\inferrule* [lab=Par-barb]{\mbox{$P\downarrow_{\mathcal N} x$ or $Q\downarrow_{\mathcal N} x$}}
		  {\binpar{P}{Q} \downarrow_{\mathcal N} x}
\end{mathpar}

We write $P \Downarrow_{\mathcal N} x$ if there is $Q$ such that 
$P \wred Q$ and $Q \downarrow_{\mathcal N} x$.
\end{defn}

\begin{defn}
%\label{def.bbisim}
An  ${\mathcal N}$-\emph{barbed bisimulation} over a set of names, ${\mathcal N}$, is a symmetric binary relation 
${\mathcal S}_{\mathcal N}$ between agents such that $P\rel{S}_{\mathcal N}Q$ implies:
\begin{enumerate}
\item If $P \red P'$ then $Q \wred Q'$ and $P'\rel{S}_{\mathcal N} Q'$.
\item If $P\downarrow_{\mathcal N} x$, then $Q\Downarrow_{\mathcal N} x$.
\end{enumerate}
$P$ is ${\mathcal N}$-barbed bisimilar to $Q$, written
$P \wbbisim_{\mathcal N} Q$, if $P \rel{S}_{\mathcal N} Q$ for some ${\mathcal N}$-barbed bisimulation ${\mathcal S}_{\mathcal N}$.
\end{defn}

\section{Interpreting policy}

In this section we present enough of namespace logic to interpret
deniability policy specification. For the reader familiar with logics
of concurrency the core idea is to use rely-guarantee combined with
the adjunct to spatial separation. Pragmatically, a visual inspection
of the code for $Cell$ reveals that if a process $P$'s names are fresh
with respect to $slot$, then $P$ cannot directly affect any $Cell(
slot, state )$. We can use the logic presented below to state and
verify the fact that $P$ cannot affect any {\tt Cell} and then
generalize and scale the approach to wider settings.

\subsection{Namespace logic}
Namespace logic resides in the subfamily of Hennessy-Milner logics
known as spatial logics, discovered by Caires and Cardelli
\cite{DBLP:conf/fossacs/Caires04}. Thus, in addition to the action
modalities, we also find at the logical level formulae for
\emph{separation} corresponding to the structural content of the
parallel operator at the level of the calculus. Likewise, we have
quantification over names. 

There are important differences between the logic presented here and
Caires' logic. Because it is built on a reflective programming language
(the \rhoc) it also has formulae, $\pquotep{\phi}$, for describing
classes of names. Said another way, the inhabitants of types of the
form $\pquotep{\phi}$ are names and hence these types have the right
to be called namespaces \cite{DBLP:conf/tgc/MeredithR05}. The next two
examples show how useful namespaces are in the security setting.

Suppose that $\pquotep{\phi}$ describes some namespace, {\em i.e.}
some collection of names. We can insist that a process restrict its
next input to names in that namespace by insisting that it witness the
formula: $\pprefix{\pquotep{\phi}}{b}{\ptrue} \& \neg
\pprefix{\pquotep{\neg \phi}}{b}{\ptrue}$ which simply says the the
process is currently able to take input from a name in the namespace
$\pquotep{\phi}$ and is not capable of input on any name not in that
namespace. 

In a similar manner, we can limit a server to serving only inputs in
$\pquotep{\phi}$ throughout the lifetime of its behavior with
$\pgfp{X}{\pprefix{\pquotep{\phi}}{b}{X} \& \neg
  \pprefix{\pquotep{\neg \phi}}{b}{X}} \nonumber$ \footnote{Of course,
  this formula also says the server never goes down, either---or at
  least is always willing to take such input.} This formula is
reminiscent of the functionality of a firewall, except that it is a
\emph{static} check. A process witnessing this formula will behave as
though it were behind a firewall admitting only access to the ports in
$\pquotep{\phi}$ without the need for the additional overhead of the
watchdog machinery.

We will use refinements this basic technique of walling off a behavior
behind a namespace when reasoning about the ocap examples and
especially in the context of deniability.

\subsubsection{Logical syntax and semantics}

\begin{mathpar}
  \inferrule* [lab=Set] {} {{\phi, \psi} \bc \ptrue \;|\; \neg \phi \;|\; \phi \& \psi}
  \and
  \inferrule* [lab=Monoid] {} {|\; \pzero \;|\; \phi \juxtap \psi}
  \and
  \inferrule* [lab=Behavior] {} {|\; \pdropf{b} \;|\; \plift{a}{\phi} \;|\; \pprefix{a}{b}{\phi}}
  \and
  \inferrule* [lab=Closure] {} {|\; \pquant{n}{\psi}{\phi} \;|\; \pgfp{X}{\phi} \;|\; X}
  \and
  \inferrule* [lab=Namespace] {} {{a} \bc \pquotep{\phi} \;|\; b}
  \and
  \inferrule* [lab=Name] {} {{b} \bc \pquotep{P} \;|\; n}
\end{mathpar} 

In the examples below, we freely employ the usual DeMorgan-based
syntactic sugar. For example, $\phi \Rightarrow \psi \defneqls \neg (
\phi \& \neg \psi )$ and $\phi \vee \psi \defneqls \neg ( \neg \phi \&
\neg \psi )$. Also, when quantification ranges over all of $\QProc$,
as in $\pquant{n}{\pquotep{\ptrue}}{\phi}$, we omit the typing for the
quantification variable, writing $\pquantuntyped{n}{\phi}$. Further,
we let $\PFormula$ denote the set of formulae generated by the
$\phi$-production, $\QFormula$ denote the set of formulae generated by
the $a$-production and $\PropVar$ denote the set of propositional
variables used in the $\textsf{rec}$ production. Additionally, we let
$\PFormula_{-Par}$ denote the separation-free fragment of formulae.

Inspired by Caires' presentation of spatial logic
\cite{DBLP:conf/fossacs/Caires04}, we give the semantics in terms of
sets of processes (and names). We need the notion of a valuation $v :
\PropVar \to \wp(\Proc)$, and use the notation $v\substn{\mathcal{S}}{X}$ to mean 

\begin{eqnarray}
  v\substn{\mathcal{S}}{X}(Y) & = &
  \left\{ \begin{array}{ccc}
      S & & Y = X \\
      v(Y) & & otherwise \\
    \end{array}
  \right.\nonumber
\end{eqnarray}

The meaning of formulae is given in terms of two mutually recursive functions,

\begin{eqnarray}
\pmeaningof{ - }( - ) : \PFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\Proc) \nonumber\\
\nmeaningof{ - }( - ) : \QFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\QProc) \nonumber
\end{eqnarray}

\noindent taking a formula of the appropriate type and a valuation, and
returning a set of processes or a set of names, respectively.

\begin{mathpar}
  \inferrule* {} {\pmeaningof{\ptrue}(v) \defneqls \Proc}
  \and
  \inferrule* {} {\pmeaningof{\neg \phi}(v) \defneqls \Proc / \pmeaningof{\phi}(v)}
  \and
  \inferrule* {} {\pmeaningof{\phi \& \psi}(v) \defneqls \pmeaningof{\phi}(v) \cap \pmeaningof{\psi}(v)}
  \and
  \inferrule* {} {\pmeaningof{\pzero}(v) \defneqls \{ P : P \scong \pzero \}}
  \and
  \inferrule* {} {\pmeaningof{\binpar{\phi}{\psi}}(v) \defneqls \{ P : \exists P_0, P_1.P \scong \binpar{P_0}{P_1}, \; P_0 \in \pmeaningof{\phi}(v), \;  P_1 \in \pmeaningof{\psi}(v) \}} \\
  \and
  \inferrule* {} {\pmeaningof{\pdropf{b}}(v) \defneqls \{ P : \exists x.P \scong {\dropn{x}}, \; x \in \nmeaningof{b}(v) \} }
  \and
  \inferrule* {} {\pmeaningof{\plift{a}{\phi}}(v) \defneqls \{ P : \exists P'.P \scong {\lift{x}{P'}}, \; x \in \nmeaningof{a}(v), \; P' \in \pmeaningof{\phi}(v) \}}
  \and
  \inferrule* {} {\pmeaningof{\pprefix{a}{b}{\phi}}(v) \defneqls \{ P : \exists P'.P \scong {\prefix{x}{y}{P'}}, x \in \nmeaningof{a}(v), \; \forall c . \exists z . {P'}\substn{z}{y} \in \pmeaningof{{\phi}\substn{c}{b}}(v) \} }
  \and \\
  \inferrule* {} {\pmeaningof{\pquant{n}{\psi}{\phi}}(v) \defneqls \cap_{x \in \nmeaningof{\quotep{\psi}}(v)} \pmeaningof{{\phi}\substn{x}{n}}(v)}
  \and
  \inferrule* {} {\pmeaningof{\pgfp{X}{\phi}}(v) \defneqls \cup \{ \mathcal{S} \subseteq \Proc : \mathcal{S} \subseteq \pmeaningof{\phi}(v\substn{\mathcal{S}}{X})\}} \\
  \inferrule* {} {\nmeaningof{\pquotep{\phi}}(v) \defneqls \{ x : x \nameeq \quotep{P}, P \in \pmeaningof{\phi}(v) \}}
  \and
  \inferrule* {} {\nmeaningof{\pquotep{P}}(v) \defneqls \{ x : x \nameeq  \quotep{P} \}}
\end{mathpar}

We say $P$ witnesses $\phi$ (resp., $x$ witnesses $\pquotep{\phi}$),
written $P \models \phi$ (resp., $x \models \pquotep{\phi}$) just when
$\forall v . P \in \meaningof{\phi}(v)$ (resp., $\forall v . x \in \meaningof{\pquotep{\phi}}(v)$).

\begin{thm}[Equivalence]\label{sec:equivalence_theorem}
	$P \wbbisim Q \riff \forall \phi \in \PFormula_{-Par} . P \models \phi \riff Q \models \phi .$
\end{thm}

A consequence of this theorem is that there is no algorithm
guaranteeing that a check for the witness relation will
terminate. However there is a large class of interesting formulae for
which the witness check does terminate, see
\cite{DBLP:conf/fossacs/Caires04}. {\em Nota bene}: including
separation makes the logic strictly more observant than bismulation.

\subsection{Applications to policy}

Adapting the firewall formula, let $soleAccess( slot ) \defneqls
\pgfp{X}{\pprefix{slot}{b}{X} \& \neg \pprefix{\neg slot}{b}{X}}$, and
$noAccess( slot ) \defneqls \pgfp{X}{\neg \pprefix{slot}{b}{X}}$; then
we have $Cell (slot, state) \models soleAccess( slot )$ which implies
${\mbox{\tt new}(slot)\mbox{\tt \{} Cell(slot, state) \mbox{\tt \}}}
\wbbisim 0$.  If we have that $P \models noAccess( slot ), \;$ then
$\forall \; state . \mbox{\tt new}(slot)\mbox{\tt \{}
\binpar{P}{Cell(slot, state)} \mbox{\tt \}}\wbbisim P.$ For, by
hypothesis, $slot$ cannot be free in $P$, thus $\mbox{\tt
  new}(slot)\mbox{\tt \{} \binpar{P}{Cell(slot, state)} \mbox{\tt \}}
\scong \binpar{P}{\mbox{\tt new}(slot)\mbox{\tt \{} Cell(slot, state)
  \mbox{\tt \}}}$ which means $\binpar{P}{\mbox{\tt
    new}(slot)\mbox{\tt \{} Cell(slot, state) \mbox{\tt \}}} \wbbisim
\binpar{P}{0} \scong P$.  More generally, note that objects involve
not just one cell, but many. By restricting those cells to slots that
live in namespace $Slot \defneqls \pquotep{\phi}$ for some $\phi$ we
can scale our formula to separate objects from a given environment.

Notice the shape of the logical statement above is: if $Q \models
\phi$ then when $P \models \psi$ we have that
$\texttt{new}(x_1,\ldots,x_N)\{ \binpar{P}{Q} \} \wbbisim S$ for some
properties $\phi$ and $\psi$ and some behavior, $S$. In light of
theorem \ref{sec:equivalence_theorem} we can, in principle, transform
this into a statement of the form, ``If $Q \models \phi,$ then when $P
\models \psi$ we have that $\texttt{new}(x_1,\ldots,x_N)\binpar{P}{Q}
\models \omega$ for some properties $\phi$, $\psi$, and $\omega$.''
This is the shape of our encoding of deniability policies. The key
insight here is to mediate between closed-world and open-world forms
of deniability. In this open-world formulation we do not quantify over
all potential contexts and attackers, but work just with those that
can be relied upon to use the API, even in attacks. Further, this
encoding emphasizes necessary rather than sufficient
conditions. Finally, notice that the form of the statement remains
true to the intent of deniability even if the logic is \emph{more}
discriminating than bisimulation---which is the case if we include the
separation operator (as noted in
\cite{DBLP:conf/fossacs/Caires04}). In the presence of a logic with
separation this shape turns out to be a form of rely-guarantee
identified by Honda in \cite{Honda:2008:UTP:2227536.2227558} and, as
Honda observes, can be internalized in the logic as the adjunct to
separation. Thus, we include a form of rely-guarantee formulae, $\phi
\rhd_{\vec{x}} \psi$, where $\vec{x} = \{ x_1,\ldots,x_N\}$, with
semantics $\pmeaningof{\phi \rhd_{\vec{x}} \psi}( v ) = \{ P : \forall
Q. Q \in \pmeaningof{\phi}( v ) \Rightarrow
\mbox{\texttt{new}}(x_1,\ldots,x_N)\mbox{\{}\binpar{P}{Q}\mbox{\}}\in
\pmeaningof{\psi}(v) \}$, as the logical form that mediates between
closed-world and open-world formulations of deniability.

\section{Conclusions and future work}

We take the simplicity and flexibility of separating cells (and
compositions of cells) from environments as evidence that the approach
is natural and commensurate with the expressiveness demands of policy
in an ocap setting. We are also interested in what this interpretation
says specifically about deniability style policies. In this connection
it is important to note that a lot is already known about the
complexity characteristics of spatial-behavioral logics. An
interpretation of deniability via rely-guarantee suggests suggests to
is a very powerful policy construct for as
\cite{Caires04eliminationof} note the addition of the adjunct to
separation is not a conservative extension!

For the interested reader, source code for implementations of an
interpreter for the {\rhoc} and a model-checker for namespace logic
are available upon request and a more industrial scale version of the
core concepts are used heavily in the \texttt{SpecialK} library
available on \texttt{github} \cite{SpecialK}. This library is already
in use in industrial projects such as the Protunity Business Matching
Network \cite{Protunity}.

\paragraph{Acknowledgments.}
The authors wish to thank Mark Miller for thoughtful and stimulating
conversation about policy, object capabilities and types. 

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{amsplain}
\bibliography{beat2014}

% ------------------------------------------------------------------------


% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
